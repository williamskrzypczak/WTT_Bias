//@version=5
indicator("WTT_Bias R1.27", "WTT_Bias R1.27", overlay=true)

// ============================================================================
// Copyright © 2025 Bulldog Ventures Inc. All rights reserved.
//
// WaveRider Trading Technologies
// 
// REVISION HISTORY:
// R1.27 - Updated lower timeframe default to 5 minutes for faster historical bias sampling
// R1.26 - Updated lower timeframe default to 10 minutes for finer historical bias resolution
// R1.25 - Enhanced bias meter table and improved reliability
//        - Added "Directional Bias" title row to bias meter table
//        - Changed "SHORTS" to "SHORT" and "LONGS" to "LONG" for cleaner labels
//        - Changed neutral marker from "N" to "NEUTRAL" for clarity
//        - Changed center cell background to lower intensity yellow (75% transparency)
//        - Changed center cell text color to black for better contrast against yellow background
//        - Reduced title text size to small for more compact table display
//        - Added robust state reset mechanism using bar_index as fallback when barstate.isnew fails
//        - This prevents histogram update issues after extended chart sessions
// R1.24 - Enhanced visual aesthetics with analog bias meter
//        - Incorporated revision number into indicator name
//        - Histogram uses darker colors for stronger bias and lighter colors for weaker bias
//        - Zero-cross markers use triangle shapes (up/down) in small size
//        - Renamed Triangle Color to Zero-Cross Marker Color for clarity
//        - Signal line uses lime/reddish-pink colors for quick recognition
//        - Added intensity decrease dots on signal line (dots appear when bias moves from stronger to weaker)
//        - Replaced info table with analog bias meter dial (bottom-right position)
//        - Meter displays bias with 5 segments: 2 shorts (left), 1 center, 2 longs (right)
//        - Red/green gradient in meter matches histogram intensity (uses current and previous bar)
//        - Up/down arrows in center cell show current bias direction
//        - Zero-cross triangles (▲/▼) appear in center cell when bias crosses zero
//        - Marker colors in center cell match histogram dot colors (lime/reddish-pink)
//        - Code cleanup: Removed unused variables and input parameters
// R1.23 - Marigold orange triangles
//        - Added Triangle Color (default Marigold #FFBF00) and applied to markers
// R1.22 - Alerts include symbol
//        - Added currency pair (symbol) to alert messages
// R1.21 - Yellow triangles for zero-cross
//        - Triangles now use Zero Color (yellow)
// R1.20 - Restored triangle markers on histogram
//        - Replaced text 0^/0v labels with triangle shapes at bias value
// R1.19 - Default: Histogram ON
//        - Enabled bias histogram by default
// R1.18 - Configurable zero-cross text size
//        - Added "Zero Text Size" setting (Tiny–Huge)
// R1.17 - Text-only zero-cross markers
//        - Replaced triangle shapes with yellow text labels (0^ / 0v)
// R1.16 - Reliable, de-duplicated alerts
//        - Added option to alert on bar close (default)
//        - Ensure one alert per bar; prioritize zero-cross events
// R1.15 - Yellow text for 0↑/0↓ markers
//        - Added configurable Zero Text Color (default yellow)
// R1.14 - Yellow zero bars in histogram
//        - Added configurable Zero Color (default yellow)
// R1.13 - Triangles on price chart; histogram off by default
//        - Switched to overlay on main price chart
//        - Disabled histogram/signal line by default to show only markers
// R1.12 - Added zero-cross chart markers
//        - Optional triangles on price chart when bias crosses zero
//        - Toggle via "Show Zero-Cross Markers" in Visual Settings
// R1.11 - Changed default table setting
//        - Set default for "Show Info Table" to false (off)
//        - Users can enable table display if desired
//        - Cleaner default appearance
// R1.10 - Updated bearish color
//        - Changed bearish color from purple to gray
//        - Maintains teal for bullish and gray for bearish/neutral
// R1.9 - Updated histogram colors
//       - Changed bullish color from green to teal
//       - Changed bearish color from red to purple
//       - Maintains neutral gray color
// R1.8 - Changed default lower timeframe
//       - Changed default lower timeframe from 1 minute to 30 minutes
//       - Updated tooltip to reflect new default
//       - Better default for most chart timeframes
// R1.7 - Made table more compact
//       - Abbreviated metric descriptions for better space efficiency
//       - "Upticks / Downticks" → "Up/Down Ticks"
//       - "Buy Volume / Sell Volume" → "Buy/Sell Vol"
//       - "Measurement Mode" → "Mode"
//       - "Smoothed Bias" → "Bias"
// R1.6 - Enhanced table color scheme
//       - Changed value column text color to blue for better contrast
//       - Keeps colored text for bias value (green/red/gray)
//       - Maintains white text for metric labels
// R1.5 - Improved table readability
//       - Changed metric column text color to white for better visibility
//       - Maintains black text for values and colored text for bias
// R1.4 - Fixed table display issue
//       - Table now recreates on each update to show metric labels
//       - Fixed issue where metric labels weren't displaying
//       - Table properly shows all data including labels
// R1.3 - Improved table metric descriptions
//       - Updated metric labels for better clarity
//       - Changed "Ticks (Up/Down)" to "Upticks / Downticks"
//       - Changed "Volume (Buy/Sell)" to "Buy Volume / Sell Volume"
//       - Changed "Bias Mode" to "Measurement Mode"
//       - Changed "Bias (S) [-1..1]" to "Smoothed Bias"
// R1.2 - Fixed info table data display
//       - Table now properly shows upticks/downticks and volume data
//       - Uses real-time data for live bar, LTF data for historical bars
//       - All table fields now populate correctly
// R1.1 - Enabled real-time info table
//       - Uncommented and activated info table display
//       - Shows upticks/downticks count in real-time
//       - Displays buy/sell volume, bias mode, and smoothed bias value
// R1.0 - Initial release - Intrabar bid/ask bias (proxy)
//       - Real-time uptick/downtick counting with volume deltas
//       - Normalized bias oscillator (-1 to +1)
//       - Optional info table and alerts
//
// This indicator approximates buy/sell (bid/ask) activity within the current
// bar by classifying real-time close changes as upticks/downticks and
// distributing the current bar's volume changes accordingly. Due to Pine
// Script's lack of true order book access, this measures a proxy, not actual
// bid/ask prints.
// ============================================================================

// ============================================================================
// INPUT PARAMETERS
// ============================================================================
// Group: Detection Settings
biasMode = input.string(
     defval="Volume",
     title="Bias Mode",
     options=["Volume", "Ticks"],
     group="Detection Settings",
     tooltip="How to measure bias: Volume uses realtime volume deltas per uptick/downtick; Ticks counts upticks vs downticks.")

sourceMode = input.string(
     defval="Auto (Realtime+History)",
     title="Source Mode",
     options=["Auto (Realtime+History)", "Realtime only", "Lower TF only"],
     group="Detection Settings",
     tooltip="Auto: realtime proxy on the last (live) bar, lower timeframe aggregation on historical bars. Realtime only: realtime proxy on live bar, lower TF on historical bars. Lower TF only: always use lower timeframe aggregation.")

lowerTf = input.timeframe(
     defval="5",
     title="Lower Timeframe (for history)",
     group="Detection Settings",
     tooltip="Timeframe used to approximate intrabar buy/sell on historical bars. Set lower than your chart TF (e.g., 30 minutes).")

neutralDeadband = input.float(
     defval=0.05,
     title="Neutral Deadband",
     minval=0.0, maxval=0.5, step=0.01,
     group="Detection Settings",
     tooltip="Bias within ±deadband is treated as neutral to suppress minor noise.")

smoothLength = input.int(
     defval=3,
     title="Smoothing Length",
     minval=1, maxval=100,
     group="Detection Settings",
     tooltip="Simple moving average length applied to the bias after deadband.")

alertThreshold = input.float(
     defval=0.20,
     title="Alert Threshold",
     minval=0.0, maxval=1.0, step=0.01,
     group="Detection Settings",
     tooltip="Trigger alerts when smoothed bias crosses above +threshold or below -threshold.")

intensityAlertEnabled = input.bool(defval=false, title="Alert When Bias Intensity Weakens", group="Detection Settings", tooltip="Send an alert when the signal line dot appears, indicating bullish or bearish momentum is easing.")

// Group: Visual Settings
showHistogram = input.bool(
     defval=true,
     title="Show Bias Histogram",
     group="Visual Settings",
     tooltip="Show bias as a histogram from -1 to +1.")

showSignalLine = input.bool(
     defval=false,
     title="Show Signal Line",
     group="Visual Settings",
     tooltip="Plot the smoothed bias as a line over the histogram.")

showBiasMeter = input.bool(
     defval=true,
     title="Show Bias Meter",
     group="Visual Settings",
     tooltip="Display an analog volume meter dial showing bias to shorts (left) and longs (right).")

showZeroCrossMarkers = input.bool(
     defval=true,
     title="Show Zero-Cross Markers",
     group="Visual Settings",
     tooltip="Plot chart markers when the bias crosses the zero line.")

showIntensityDecreaseDots = input.bool(
     defval=true,
     title="Show Intensity Decrease Dots",
     group="Visual Settings",
     tooltip="Plot dots on signal line when bias intensity decreases (stronger to weaker).")

// Group: Alert Settings
alertOnBarClose = input.bool(
     defval=true,
     title="Alerts on Bar Close (More Reliable)",
     group="Alert Settings",
     tooltip="When enabled, alerts trigger once per bar at close using the final values, reducing missed triggers.")

// Group: Colors
bullishColor = input.color(
     defval=color.new(color.teal, 0),
     title="Bullish Color",
     group="Colors")

bearishColor = input.color(
     defval=color.new(color.gray, 0),
     title="Bearish Color",
     group="Colors")

neutralColor = input.color(
     defval=color.new(color.gray, 0),
     title="Neutral Color",
     group="Colors")

zeroColor = input.color(
     defval=color.new(color.yellow, 0),
     title="Zero Color",
     group="Colors")

markerColor = input.color(
     defval=color.new(color.rgb(255, 191, 0), 0),
     title="Zero-Cross Marker Color (Marigold)",
     group="Colors",
     tooltip="Color for diamond markers that appear when bias crosses zero.")

histTransparency = input.int(
     defval=10,
     title="Histogram Transparency (0-100)",
     minval=0, maxval=100,
     group="Colors")

lineTransparency = input.int(
     defval=0,
     title="Line Transparency (0-100)",
     minval=0, maxval=100,
     group="Colors")

// ============================================================================
// CALCULATIONS - REALTIME PROXY (LAST BAR)
// ============================================================================
// State variables for intrabar counting
var int upTickCount = 0
var int downTickCount = 0
var float buyVolume = 0.0
var float sellVolume = 0.0
var float lastCloseRt = na
var float lastVolumeRt = na
var int lastBarIndex = na
var float lastEvaluatedBias = na

// Robust reset: check both barstate.isnew and bar_index change for reliability
// This handles cases where barstate detection might fail after extended sessions
isNewBar = barstate.isnew or (not na(lastBarIndex) and bar_index != lastBarIndex)
if isNewBar
    upTickCount := 0
    downTickCount := 0
    buyVolume := 0.0
    sellVolume := 0.0
    lastCloseRt := close
    lastVolumeRt := volume
    lastBarIndex := bar_index

// On each realtime update of current bar, classify uptick/downtick and allocate volume delta
if barstate.isrealtime
    priceDelta = close - nz(lastCloseRt, close)
    volumeDelta = math.max(volume - nz(lastVolumeRt, volume), 0)
    isUpTick = priceDelta > 0
    isDownTick = priceDelta < 0

    if isUpTick
        upTickCount := upTickCount + 1
        buyVolume := buyVolume + volumeDelta
    else if isDownTick
        downTickCount := downTickCount + 1
        sellVolume := sellVolume + volumeDelta
    else
        // No price change: evenly apportion any volume delta
        buyVolume := buyVolume + volumeDelta * 0.5
        sellVolume := sellVolume + volumeDelta * 0.5

    lastCloseRt := close
    lastVolumeRt := volume

// Realtime raw biases
rtTickTotal = upTickCount + downTickCount
rtTickBiasRaw = rtTickTotal > 0 ? (upTickCount - downTickCount) / rtTickTotal : 0.0
rtVolTotal = buyVolume + sellVolume
rtVolBiasRaw = rtVolTotal > 0 ? (buyVolume - sellVolume) / rtVolTotal : 0.0

// ============================================================================
// CALCULATIONS - LOWER TIMEFRAME AGGREGATION (HISTORICAL & OPTIONAL LIVE)
// ============================================================================
// Helper functions evaluated in lower timeframe context
calcLtfBuyAgg() =>
    barBuy = close > close[1] ? volume : close < close[1] ? 0.0 : volume * 0.5
    cumBuy = ta.cum(barBuy)
    newHtfBar = ta.change(time(timeframe.period))
    startCum = nz(ta.valuewhen(newHtfBar, cumBuy[1], 0), 0.0)
    cumBuy - startCum

calcLtfSellAgg() =>
    barSell = close < close[1] ? volume : close > close[1] ? 0.0 : volume * 0.5
    cumSell = ta.cum(barSell)
    newHtfBar = ta.change(time(timeframe.period))
    startCum = nz(ta.valuewhen(newHtfBar, cumSell[1], 0), 0.0)
    cumSell - startCum

calcLtfUpAgg() =>
    barUp = close > close[1] ? 1.0 : 0.0
    cumUp = ta.cum(barUp)
    newHtfBar = ta.change(time(timeframe.period))
    startCum = nz(ta.valuewhen(newHtfBar, cumUp[1], 0), 0.0)
    cumUp - startCum

calcLtfDownAgg() =>
    barDown = close < close[1] ? 1.0 : 0.0
    cumDown = ta.cum(barDown)
    newHtfBar = ta.change(time(timeframe.period))
    startCum = nz(ta.valuewhen(newHtfBar, cumDown[1], 0), 0.0)
    cumDown - startCum

// Inside the lower timeframe, classify each LTF bar by tick rule and accumulate within the current chart TF bar boundaries.
ltfBuyAgg = request.security(syminfo.tickerid, lowerTf, calcLtfBuyAgg(), barmerge.gaps_off, barmerge.lookahead_off)
ltfSellAgg = request.security(syminfo.tickerid, lowerTf, calcLtfSellAgg(), barmerge.gaps_off, barmerge.lookahead_off)

// LTF ticks approximation: count up/down bars at the lower timeframe
ltfUpAgg = request.security(syminfo.tickerid, lowerTf, calcLtfUpAgg(), barmerge.gaps_off, barmerge.lookahead_off)
ltfDownAgg = request.security(syminfo.tickerid, lowerTf, calcLtfDownAgg(), barmerge.gaps_off, barmerge.lookahead_off)

ltfVolTotal = ltfBuyAgg + ltfSellAgg
ltfVolBiasRaw = ltfVolTotal > 0 ? (ltfBuyAgg - ltfSellAgg) / ltfVolTotal : 0.0
ltfTickTotal = ltfUpAgg + ltfDownAgg
ltfTickBiasRaw = ltfTickTotal > 0 ? (ltfUpAgg - ltfDownAgg) / ltfTickTotal : 0.0

// ============================================================================
// CALCULATIONS - SELECTED SOURCE AND MODE
// ============================================================================
useRealtime = (sourceMode == "Realtime only" and barstate.isrealtime) or (sourceMode == "Auto (Realtime+History)" and barstate.isrealtime)

rawBias = biasMode == "Volume"
     ? (useRealtime ? rtVolBiasRaw : ltfVolBiasRaw)
     : (useRealtime ? rtTickBiasRaw : ltfTickBiasRaw)

// Apply deadband
applyDeadband(val, db) => math.abs(val) < db ? 0.0 : val
biased = applyDeadband(rawBias, neutralDeadband)

// Smooth
smoothedBias = ta.sma(biased, smoothLength)

// Calculate bias intensity for dynamic color darkness
// Stronger bias = darker colors (less transparency = darker/more solid)
// Weaker bias = lighter colors (more transparency = lighter/more faded)
biasIntensity = math.abs(smoothedBias)

// Calculate transparency based on bias strength
// Strong bias (near ±1.0) → low transparency (dark green/gray)
// Weak bias (near 0) → high transparency (light green/gray)
// Formula: darkness increases with bias strength
// Maximum lightness for weakest bias (high transparency ~55-60)
// Minimum lightness for strongest bias (low transparency ~0-10)
maxLightness = 60  // Maximum transparency for weakest bias (reduced for more intensity)
effectiveTransparency = smoothedBias == 0 ? histTransparency : 
          math.max(0, math.min(100, maxLightness * (1 - biasIntensity)))

// Get base color for histogram
histogramBaseColor = smoothedBias == 0 ? zeroColor : (smoothedBias > 0 ? bullishColor : bearishColor)
histogramColor = color.new(histogramBaseColor, effectiveTransparency)

// Track bias transitions using last evaluated value for alert/table alignment
previousEvaluatedBias = na(lastEvaluatedBias) ? nz(smoothedBias[1]) : lastEvaluatedBias
flippedBull = previousEvaluatedBias <= 0 and smoothedBias > 0
flippedBear = previousEvaluatedBias >= 0 and smoothedBias < 0
turnedBullish = previousEvaluatedBias <= alertThreshold and smoothedBias > alertThreshold
turnedBearish = previousEvaluatedBias >= -alertThreshold and smoothedBias < -alertThreshold

// ============================================================================
// VISUAL ELEMENTS
// ============================================================================
hZero = hline(0.0, "Zero Line", color=color.new(color.gray, 60))
plot(showHistogram ? smoothedBias : na, "Bias", style=plot.style_columns, color=smoothedBias == 0 ? color.new(zeroColor, effectiveTransparency) : histogramColor)
// Signal line with lime, reddish-pink, or gray for quick directional recognition
signalLineColor = smoothedBias > 0 ? color.new(color.rgb(191, 255, 0), lineTransparency) : smoothedBias < 0 ? color.new(color.rgb(255, 100, 140), lineTransparency) : color.new(color.gray, lineTransparency)
plot(showSignalLine ? smoothedBias : na, "Signal", color=signalLineColor, linewidth=2)

// Detect when bias intensity decreases (stronger to weaker)
previousBiasIntensity = math.abs(smoothedBias[1])
currentBiasIntensity = math.abs(smoothedBias)
intensityDecreased = currentBiasIntensity < previousBiasIntensity and not na(previousBiasIntensity)
intensityDirection = smoothedBias > 0 ? "bullish" : smoothedBias < 0 ? "bearish" : "neutral"
intensityDescription = intensityDirection == "neutral" ? "Neutral bias momentum compressing" : intensityDirection == "bullish" ? "Bullish momentum easing" : "Bearish momentum easing"

// Plot dot on signal line when intensity decreases
plotshape(showSignalLine and showIntensityDecreaseDots and intensityDecreased ? smoothedBias : na, title="Intensity Decrease Dot", style=shape.circle, location=location.absolute, color=signalLineColor, size=size.tiny)

// Zero-cross visual markers will be plotted after zero-cross detection

// ============================================================================
// ANALOG BIAS METER DIAL
// ============================================================================
var table biasMeterTable = na
if showBiasMeter and barstate.islast
    // Delete existing table to recreate with updated data
    if not na(biasMeterTable)
        table.delete(biasMeterTable)
    
    // Create meter table: 9 columns (4 shorts + 1 center + 4 longs), 3 rows
    biasMeterTable := table.new(position.bottom_right, 9, 3, bgcolor=color.new(color.white, 50), border_width=0)
    
    // Convert smoothedBias (-1.0 to +1.0) to segment index (0-8)
    // Segment mapping: 0-3 = shorts (strong to weak), 4 = center, 5-8 = longs (weak to strong)
    normalizedBias = math.max(-1.0, math.min(1.0, smoothedBias))
    // Map bias to 9 segments: 
    // -1.0 to -0.75 = 0 (very strong shorts), -0.75 to -0.5 = 1 (strong shorts),
    // -0.5 to -0.25 = 2 (medium shorts), -0.25 to -0.1 = 3 (weak shorts),
    // -0.1 to 0.1 = 4 (center), 0.1 to 0.25 = 5 (weak longs), 0.25 to 0.5 = 6 (medium longs),
    // 0.5 to 0.75 = 7 (strong longs), 0.75 to 1.0 = 8 (very strong longs)
    segmentIndex = normalizedBias < -0.75 ? 0 : normalizedBias < -0.5 ? 1 : normalizedBias < -0.25 ? 2 : normalizedBias < -0.1 ? 3 : math.abs(normalizedBias) <= 0.1 ? 4 : normalizedBias < 0.25 ? 5 : normalizedBias < 0.5 ? 6 : normalizedBias < 0.75 ? 7 : 8
    
    // Determine current bias direction
    isShortsBias = normalizedBias < -0.1
    isLongsBias = normalizedBias > 0.1
    isNeutralBias = math.abs(normalizedBias) <= 0.1
    
    // Detect intensity decrease (compare current to previous bar)
    previousBiasIntensity = math.abs(smoothedBias[1])
    currentBiasIntensity = math.abs(normalizedBias)
    intensityDecreased = currentBiasIntensity < previousBiasIntensity and not na(previousBiasIntensity)
    
    // Determine triangle marker and intensity dot
    baseMarker = isShortsBias ? "▼" : isLongsBias ? "▲" : "NEUTRAL"
    intensityDot = "●"  // Dot to show when intensity decreases
    // When intensity decreases, reverse the arrow and place it after the dot
    reversedMarker = baseMarker == "▼" ? "▲" : baseMarker == "▲" ? "▼" : baseMarker
    
    // Row 0: Title row - "Directional Bias"
    table.cell(biasMeterTable, 0, 0, "", bgcolor=color.black)  // Empty cell
    table.cell(biasMeterTable, 1, 0, "", bgcolor=color.black)  // Empty cell
    table.cell(biasMeterTable, 2, 0, "", bgcolor=color.black)  // Empty cell
    table.cell(biasMeterTable, 3, 0, "", bgcolor=color.black)  // Empty cell
    table.cell(biasMeterTable, 4, 0, "CDB", bgcolor=color.black, text_color=color.white, text_size=size.small, text_halign=text.align_center)
    table.cell(biasMeterTable, 5, 0, "", bgcolor=color.black)  // Empty cell
    table.cell(biasMeterTable, 6, 0, "", bgcolor=color.black)  // Empty cell
    table.cell(biasMeterTable, 7, 0, "", bgcolor=color.black)  // Empty cell
    table.cell(biasMeterTable, 8, 0, "", bgcolor=color.black)  // Empty cell
    
    // Row 1: Labels row - black background, highlight current bias direction
    shortsLabelText = isShortsBias ? color.white : color.red
    table.cell(biasMeterTable, 0, 1, "SHORT", bgcolor=color.black, text_color=shortsLabelText, text_size=size.small, text_halign=text.align_left)
    table.cell(biasMeterTable, 1, 1, "", bgcolor=color.black)  // Empty cell
    table.cell(biasMeterTable, 2, 1, "", bgcolor=color.black)  // Empty cell
    table.cell(biasMeterTable, 3, 1, "", bgcolor=color.black)  // Empty cell
    
    centerLabelText = isNeutralBias ? color.white : color.gray
    table.cell(biasMeterTable, 4, 1, "0", bgcolor=color.black, text_color=centerLabelText, text_size=size.small, text_halign=text.align_center)
    
    table.cell(biasMeterTable, 5, 1, "", bgcolor=color.black)  // Empty cell
    table.cell(biasMeterTable, 6, 1, "", bgcolor=color.black)  // Empty cell
    table.cell(biasMeterTable, 7, 1, "", bgcolor=color.black)  // Empty cell
    longsLabelText = isLongsBias ? color.white : color.green
    table.cell(biasMeterTable, 8, 1, "LONG", bgcolor=color.black, text_color=longsLabelText, text_size=size.small, text_halign=text.align_right)
    
    // Row 2: Red-green gradient matching histogram intensity exactly
    // Use exact same intensity calculation as histogram bars
    maxLightness = 60  // Same as histogram
    
    // Calculate histogram intensity for current and previous bars (matching histogram calculation)
    currentHistBiasIntensity = math.abs(smoothedBias)
    previousHistBiasIntensity = math.abs(smoothedBias[1])
    
    // Calculate histogram effective transparency (same as histogram bars)
    currentHistTransparency = smoothedBias == 0 ? histTransparency : 
              math.max(0, math.min(100, maxLightness * (1 - currentHistBiasIntensity)))
    previousHistTransparency = not na(smoothedBias[1]) and smoothedBias[1] == 0 ? histTransparency : 
              math.max(0, math.min(100, maxLightness * (1 - previousHistBiasIntensity)))
    
    // Map histogram transparency to RGB intensity
    // Histogram: low transparency (0) = dark/intense, high transparency (60) = light/faded
    // RGB: low transparency = high RGB (bright), high transparency = low RGB (dim)
    // Invert transparency to get RGB intensity: RGB = 255 * (1 - transparency/60) mapped to 0.3-1.0 range for brighter visibility
    currentRgbIntensity = 0.3 + (1.0 - currentHistTransparency / maxLightness) * 0.7
    previousRgbIntensity = not na(smoothedBias[1]) ? (0.3 + (1.0 - previousHistTransparency / maxLightness) * 0.7) : 0.3
    
    // Segments 0-3: Shorts (red gradient) - fill from center outward
    // Segment 0: Very strong shorts (far left) - uses current bar when bias < -0.75
    seg0Active = normalizedBias < -0.75
    seg0RgbValue = seg0Active ? int(255 * currentRgbIntensity) : 0
    seg0Color = seg0Active ? color.rgb(seg0RgbValue, 0, 0) : color.black
    table.cell(biasMeterTable, 0, 2, "", bgcolor=seg0Color, text_color=color.white, text_size=size.small, text_halign=text.align_center)
    
    // Segment 1: Strong shorts - uses current bar when bias < -0.5
    seg1Active = normalizedBias < -0.5
    seg1RgbValue = seg1Active ? int(255 * currentRgbIntensity) : 0
    seg1Color = seg1Active ? color.rgb(seg1RgbValue, 0, 0) : color.black
    table.cell(biasMeterTable, 1, 2, "", bgcolor=seg1Color, text_color=color.white, text_size=size.small, text_halign=text.align_center)
    
    // Segment 2: Medium shorts - uses previous bar when bias < -0.25
    seg2Active = normalizedBias < -0.25
    seg2RgbValue = seg2Active ? int(255 * previousRgbIntensity) : 0
    seg2Color = seg2Active ? color.rgb(seg2RgbValue, 0, 0) : color.black
    table.cell(biasMeterTable, 2, 2, "", bgcolor=seg2Color, text_color=color.white, text_size=size.small, text_halign=text.align_center)
    
    // Segment 3: Weak shorts - uses previous bar when bias < -0.1
    seg3Active = normalizedBias < -0.1
    seg3RgbValue = seg3Active ? int(255 * previousRgbIntensity) : 0
    seg3Color = seg3Active ? color.rgb(seg3RgbValue, 0, 0) : color.black
    table.cell(biasMeterTable, 3, 2, "", bgcolor=seg3Color, text_color=color.white, text_size=size.small, text_halign=text.align_center)
    
    // Segment 4: Center - shows zero-cross triangle when it occurs
    centerActive = math.abs(normalizedBias) <= 0.1 or segmentIndex == 4
    // Use lower intensity yellow background for center cell
    centerSegColor = centerActive ? color.new(color.yellow, 75) : color.black
    // Detect zero-cross for triangle marker in center cell (up triangle for bullish cross, down for bearish)
    zeroCrossBull = flippedBull
    zeroCrossBear = flippedBear
    // Current bar marker (triangle or dot with intensity decrease indicator)
    // When neutral, show "NEUTRAL" regardless of intensity change
    currentBarMarker = isNeutralBias ? "NEUTRAL" : (intensityDecreased ? intensityDot + reversedMarker : baseMarker)
    // Show zero-cross triangle if it occurs, otherwise show current bar marker
    centerText = zeroCrossBull ? "▲" : zeroCrossBear ? "▼" : currentBarMarker
    // Use black text for better contrast against yellow background
    centerTextColor = color.black
    table.cell(biasMeterTable, 4, 2, centerText, bgcolor=centerSegColor, text_color=centerTextColor, text_size=size.small, text_halign=text.align_center)
    
    // Segments 5-8: Longs (green gradient) - fill from center outward
    // Segment 5: Weak longs - uses previous bar when bias > 0.1
    seg5Active = normalizedBias > 0.1
    seg5RgbValue = seg5Active ? int(255 * previousRgbIntensity) : 0
    seg5Color = seg5Active ? color.rgb(0, seg5RgbValue, 0) : color.black
    table.cell(biasMeterTable, 5, 2, "", bgcolor=seg5Color, text_color=color.white, text_size=size.small, text_halign=text.align_center)
    
    // Segment 6: Medium longs - uses previous bar when bias > 0.25
    seg6Active = normalizedBias > 0.25
    seg6RgbValue = seg6Active ? int(255 * previousRgbIntensity) : 0
    seg6Color = seg6Active ? color.rgb(0, seg6RgbValue, 0) : color.black
    table.cell(biasMeterTable, 6, 2, "", bgcolor=seg6Color, text_color=color.white, text_size=size.small, text_halign=text.align_center)
    
    // Segment 7: Strong longs - uses current bar when bias > 0.5
    seg7Active = normalizedBias > 0.5
    seg7RgbValue = seg7Active ? int(255 * currentRgbIntensity) : 0
    seg7Color = seg7Active ? color.rgb(0, seg7RgbValue, 0) : color.black
    table.cell(biasMeterTable, 7, 2, "", bgcolor=seg7Color, text_color=color.white, text_size=size.small, text_halign=text.align_center)
    
    // Segment 8: Very strong longs (far right) - uses current bar when bias > 0.75
    seg8Active = normalizedBias > 0.75
    seg8RgbValue = seg8Active ? int(255 * currentRgbIntensity) : 0
    seg8Color = seg8Active ? color.rgb(0, seg8RgbValue, 0) : color.black
    table.cell(biasMeterTable, 8, 2, "", bgcolor=seg8Color, text_color=color.white, text_size=size.small, text_halign=text.align_center)

// =========================================================================
// ALERTS
// =========================================================================
// Zero-cross visual markers (triangle shapes at bias level on histogram)
bullFlipSignal = showZeroCrossMarkers and flippedBull
bearFlipSignal = showZeroCrossMarkers and flippedBear

plotshape(bullFlipSignal ? smoothedBias : na, title="Zero-Cross Up", style=shape.triangleup, location=location.absolute, color=markerColor, size=size.small)

plotshape(bearFlipSignal ? smoothedBias : na, title="Zero-Cross Down", style=shape.triangledown, location=location.absolute, color=markerColor, size=size.small)

// Emit at most one alert per bar with priority: zero-cross > threshold
shouldEvaluateNow = alertOnBarClose ? barstate.isconfirmed : barstate.isconfirmed or barstate.isrealtime
if shouldEvaluateNow
    string alertMsg = na
    if flippedBull
        alertMsg := "WTT_Bias (" + syminfo.ticker + "): Bias flipped above 0"
    else if flippedBear
        alertMsg := "WTT_Bias (" + syminfo.ticker + "): Bias flipped below 0"
    else if turnedBullish
        alertMsg := "WTT_Bias (" + syminfo.ticker + "): Bias crossed above +" + str.tostring(alertThreshold)
    else if turnedBearish
        alertMsg := "WTT_Bias (" + syminfo.ticker + "): Bias crossed below -" + str.tostring(alertThreshold)
    else if intensityAlertEnabled and intensityDecreased
        alertMsg := "WTT_Bias (" + syminfo.ticker + "): " + intensityDescription

    if not na(alertMsg)
        alert(alertMsg, alertOnBarClose ? alert.freq_once_per_bar_close : alert.freq_once_per_bar)

    lastEvaluatedBias := smoothedBias
